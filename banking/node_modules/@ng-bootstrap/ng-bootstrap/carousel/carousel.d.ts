import { AfterContentChecked, AfterContentInit, ChangeDetectorRef, ElementRef, EventEmitter, NgZone, OnDestroy, QueryList, TemplateRef, AfterViewInit } from '@angular/core';
import { NgbCarouselConfig } from './carousel-config';
import { NgbSlideEventDirection } from './carousel-transition';
/**
 * A directive that wraps the individual carousel slide.
 */
import * as ɵngcc0 from '@angular/core';
export declare class NgbSlide {
    tplRef: TemplateRef<any>;
    /**
     * Slide id that must be unique for the entire document.
     *
     * If not provided, will be generated in the `ngb-slide-xx` format.
     */
    id: string;
    /**
     * An event emitted when the slide transition is finished
     *
     * @since 8.0.0
     */
    slid: EventEmitter<NgbSingleSlideEvent>;
    constructor(tplRef: TemplateRef<any>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbSlide, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgbSlide, "ng-template[ngbSlide]", never, { "id": "id"; }, { "slid": "slid"; }, never>;
}
/**
 * Carousel is a component to easily create and control slideshows.
 *
 * Allows to set intervals, change the way user interacts with the slides and provides a programmatic API.
 */
export declare class NgbCarousel implements AfterContentChecked, AfterContentInit, AfterViewInit, OnDestroy {
    private _platformId;
    private _ngZone;
    private _cd;
    private _container;
    slides: QueryList<NgbSlide>;
    NgbSlideEventSource: typeof NgbSlideEventSource;
    private _destroy$;
    private _interval$;
    private _mouseHover$;
    private _focused$;
    private _pauseOnHover$;
    private _pauseOnFocus$;
    private _pause$;
    private _wrap$;
    /**
     * A flag to enable/disable the animations.
     *
     * @since 8.0.0
     */
    animation: boolean;
    /**
     * The slide id that should be displayed **initially**.
     *
     * For subsequent interactions use methods `select()`, `next()`, etc. and the `(slide)` output.
     */
    activeId: string;
    /**
     * Time in milliseconds before the next slide is shown.
     */
    set interval(value: number);
    get interval(): number;
    /**
     * If `true`, will 'wrap' the carousel by switching from the last slide back to the first.
     */
    set wrap(value: boolean);
    get wrap(): boolean;
    /**
     * If `true`, allows to interact with carousel using keyboard 'arrow left' and 'arrow right'.
     */
    keyboard: boolean;
    /**
     * If `true`, will pause slide switching when mouse cursor hovers the slide.
     *
     * @since 2.2.0
     */
    set pauseOnHover(value: boolean);
    get pauseOnHover(): boolean;
    /**
     * If `true`, will pause slide switching when the focus is inside the carousel.
     */
    set pauseOnFocus(value: boolean);
    get pauseOnFocus(): boolean;
    /**
     * If `true`, 'previous' and 'next' navigation arrows will be visible on the slide.
     *
     * @since 2.2.0
     */
    showNavigationArrows: boolean;
    /**
     * If `true`, navigation indicators at the bottom of the slide will be visible.
     *
     * @since 2.2.0
     */
    showNavigationIndicators: boolean;
    /**
     * An event emitted just before the slide transition starts.
     *
     * See [`NgbSlideEvent`](#/components/carousel/api#NgbSlideEvent) for payload details.
     */
    slide: EventEmitter<NgbSlideEvent>;
    /**
     * An event emitted right after the slide transition is completed.
     *
     * See [`NgbSlideEvent`](#/components/carousel/api#NgbSlideEvent) for payload details.
     *
     * @since 8.0.0
     */
    slid: EventEmitter<NgbSlideEvent>;
    private _transitionIds;
    set mouseHover(value: boolean);
    get mouseHover(): boolean;
    set focused(value: boolean);
    get focused(): boolean;
    constructor(config: NgbCarouselConfig, _platformId: any, _ngZone: NgZone, _cd: ChangeDetectorRef, _container: ElementRef);
    arrowLeft(): void;
    arrowRight(): void;
    ngAfterContentInit(): void;
    ngAfterContentChecked(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    /**
     * Navigates to a slide with the specified identifier.
     */
    select(slideId: string, source?: NgbSlideEventSource): void;
    /**
     * Navigates to the previous slide.
     */
    prev(source?: NgbSlideEventSource): void;
    /**
     * Navigates to the next slide.
     */
    next(source?: NgbSlideEventSource): void;
    /**
     * Pauses cycling through the slides.
     */
    pause(): void;
    /**
     * Restarts cycling through the slides from left to right.
     */
    cycle(): void;
    /**
     * Set the focus on the carousel.
     */
    focus(): void;
    private _cycleToSelected;
    private _getSlideEventDirection;
    private _getSlideById;
    private _getSlideIdxById;
    private _getNextSlide;
    private _getPrevSlide;
    private _getSlideElement;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbCarousel, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NgbCarousel, "ngb-carousel", ["ngbCarousel"], { "animation": "animation"; "interval": "interval"; "wrap": "wrap"; "keyboard": "keyboard"; "pauseOnHover": "pauseOnHover"; "pauseOnFocus": "pauseOnFocus"; "showNavigationArrows": "showNavigationArrows"; "showNavigationIndicators": "showNavigationIndicators"; "activeId": "activeId"; }, { "slide": "slide"; "slid": "slid"; }, ["slides"], never>;
}
/**
 * A slide change event emitted right after the slide transition is completed.
 */
export interface NgbSlideEvent {
    /**
     * The previous slide id.
     */
    prev: string;
    /**
     * The current slide id.
     */
    current: string;
    /**
     * The slide event direction.
     *
     * Possible values are `'left' | 'right'`.
     */
    direction: NgbSlideEventDirection;
    /**
     * Whether the pause() method was called (and no cycle() call was done afterwards).
     *
     * @since 5.1.0
     */
    paused: boolean;
    /**
     * Source triggering the slide change event.
     *
     * Possible values are `'timer' | 'arrowLeft' | 'arrowRight' | 'indicator'`
     *
     * @since 5.1.0
     */
    source?: NgbSlideEventSource;
}
/**
 * A slide change event emitted right after the slide transition is completed.
 *
 * @since 8.0.0
 */
export interface NgbSingleSlideEvent {
    /**
     * true if the slide is shown, false otherwise
     */
    isShown: boolean;
    /**
     * The slide event direction.
     *
     * Possible values are `'left' | 'right'`.
     */
    direction: NgbSlideEventDirection;
    /**
     * Source triggering the slide change event.
     *
     * Possible values are `'timer' | 'arrowLeft' | 'arrowRight' | 'indicator'`
     *
     */
    source?: NgbSlideEventSource;
}
export declare enum NgbSlideEventSource {
    TIMER = "timer",
    ARROW_LEFT = "arrowLeft",
    ARROW_RIGHT = "arrowRight",
    INDICATOR = "indicator"
}
export declare const NGB_CAROUSEL_DIRECTIVES: (typeof NgbSlide | typeof NgbCarousel)[];

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwuZC50cyIsInNvdXJjZXMiOlsiY2Fyb3VzZWwuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgQWZ0ZXJDb250ZW50SW5pdCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgTmdab25lLCBPbkRlc3Ryb3ksIFF1ZXJ5TGlzdCwgVGVtcGxhdGVSZWYsIEFmdGVyVmlld0luaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTmdiQ2Fyb3VzZWxDb25maWcgfSBmcm9tICcuL2Nhcm91c2VsLWNvbmZpZyc7XHJcbmltcG9ydCB7IE5nYlNsaWRlRXZlbnREaXJlY3Rpb24gfSBmcm9tICcuL2Nhcm91c2VsLXRyYW5zaXRpb24nO1xyXG4vKipcclxuICogQSBkaXJlY3RpdmUgdGhhdCB3cmFwcyB0aGUgaW5kaXZpZHVhbCBjYXJvdXNlbCBzbGlkZS5cclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5nYlNsaWRlIHtcclxuICAgIHRwbFJlZjogVGVtcGxhdGVSZWY8YW55PjtcclxuICAgIC8qKlxyXG4gICAgICogU2xpZGUgaWQgdGhhdCBtdXN0IGJlIHVuaXF1ZSBmb3IgdGhlIGVudGlyZSBkb2N1bWVudC5cclxuICAgICAqXHJcbiAgICAgKiBJZiBub3QgcHJvdmlkZWQsIHdpbGwgYmUgZ2VuZXJhdGVkIGluIHRoZSBgbmdiLXNsaWRlLXh4YCBmb3JtYXQuXHJcbiAgICAgKi9cclxuICAgIGlkOiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2xpZGUgdHJhbnNpdGlvbiBpcyBmaW5pc2hlZFxyXG4gICAgICpcclxuICAgICAqIEBzaW5jZSA4LjAuMFxyXG4gICAgICovXHJcbiAgICBzbGlkOiBFdmVudEVtaXR0ZXI8TmdiU2luZ2xlU2xpZGVFdmVudD47XHJcbiAgICBjb25zdHJ1Y3Rvcih0cGxSZWY6IFRlbXBsYXRlUmVmPGFueT4pO1xyXG59XHJcbi8qKlxyXG4gKiBDYXJvdXNlbCBpcyBhIGNvbXBvbmVudCB0byBlYXNpbHkgY3JlYXRlIGFuZCBjb250cm9sIHNsaWRlc2hvd3MuXHJcbiAqXHJcbiAqIEFsbG93cyB0byBzZXQgaW50ZXJ2YWxzLCBjaGFuZ2UgdGhlIHdheSB1c2VyIGludGVyYWN0cyB3aXRoIHRoZSBzbGlkZXMgYW5kIHByb3ZpZGVzIGEgcHJvZ3JhbW1hdGljIEFQSS5cclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5nYkNhcm91c2VsIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcclxuICAgIHByaXZhdGUgX3BsYXRmb3JtSWQ7XHJcbiAgICBwcml2YXRlIF9uZ1pvbmU7XHJcbiAgICBwcml2YXRlIF9jZDtcclxuICAgIHByaXZhdGUgX2NvbnRhaW5lcjtcclxuICAgIHNsaWRlczogUXVlcnlMaXN0PE5nYlNsaWRlPjtcclxuICAgIE5nYlNsaWRlRXZlbnRTb3VyY2U6IHR5cGVvZiBOZ2JTbGlkZUV2ZW50U291cmNlO1xyXG4gICAgcHJpdmF0ZSBfZGVzdHJveSQ7XHJcbiAgICBwcml2YXRlIF9pbnRlcnZhbCQ7XHJcbiAgICBwcml2YXRlIF9tb3VzZUhvdmVyJDtcclxuICAgIHByaXZhdGUgX2ZvY3VzZWQkO1xyXG4gICAgcHJpdmF0ZSBfcGF1c2VPbkhvdmVyJDtcclxuICAgIHByaXZhdGUgX3BhdXNlT25Gb2N1cyQ7XHJcbiAgICBwcml2YXRlIF9wYXVzZSQ7XHJcbiAgICBwcml2YXRlIF93cmFwJDtcclxuICAgIC8qKlxyXG4gICAgICogQSBmbGFnIHRvIGVuYWJsZS9kaXNhYmxlIHRoZSBhbmltYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBzaW5jZSA4LjAuMFxyXG4gICAgICovXHJcbiAgICBhbmltYXRpb246IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzbGlkZSBpZCB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgKippbml0aWFsbHkqKi5cclxuICAgICAqXHJcbiAgICAgKiBGb3Igc3Vic2VxdWVudCBpbnRlcmFjdGlvbnMgdXNlIG1ldGhvZHMgYHNlbGVjdCgpYCwgYG5leHQoKWAsIGV0Yy4gYW5kIHRoZSBgKHNsaWRlKWAgb3V0cHV0LlxyXG4gICAgICovXHJcbiAgICBhY3RpdmVJZDogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaW1lIGluIG1pbGxpc2Vjb25kcyBiZWZvcmUgdGhlIG5leHQgc2xpZGUgaXMgc2hvd24uXHJcbiAgICAgKi9cclxuICAgIHNldCBpbnRlcnZhbCh2YWx1ZTogbnVtYmVyKTtcclxuICAgIGdldCBpbnRlcnZhbCgpOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIElmIGB0cnVlYCwgd2lsbCAnd3JhcCcgdGhlIGNhcm91c2VsIGJ5IHN3aXRjaGluZyBmcm9tIHRoZSBsYXN0IHNsaWRlIGJhY2sgdG8gdGhlIGZpcnN0LlxyXG4gICAgICovXHJcbiAgICBzZXQgd3JhcCh2YWx1ZTogYm9vbGVhbik7XHJcbiAgICBnZXQgd3JhcCgpOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBgdHJ1ZWAsIGFsbG93cyB0byBpbnRlcmFjdCB3aXRoIGNhcm91c2VsIHVzaW5nIGtleWJvYXJkICdhcnJvdyBsZWZ0JyBhbmQgJ2Fycm93IHJpZ2h0Jy5cclxuICAgICAqL1xyXG4gICAga2V5Ym9hcmQ6IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIElmIGB0cnVlYCwgd2lsbCBwYXVzZSBzbGlkZSBzd2l0Y2hpbmcgd2hlbiBtb3VzZSBjdXJzb3IgaG92ZXJzIHRoZSBzbGlkZS5cclxuICAgICAqXHJcbiAgICAgKiBAc2luY2UgMi4yLjBcclxuICAgICAqL1xyXG4gICAgc2V0IHBhdXNlT25Ib3Zlcih2YWx1ZTogYm9vbGVhbik7XHJcbiAgICBnZXQgcGF1c2VPbkhvdmVyKCk6IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIElmIGB0cnVlYCwgd2lsbCBwYXVzZSBzbGlkZSBzd2l0Y2hpbmcgd2hlbiB0aGUgZm9jdXMgaXMgaW5zaWRlIHRoZSBjYXJvdXNlbC5cclxuICAgICAqL1xyXG4gICAgc2V0IHBhdXNlT25Gb2N1cyh2YWx1ZTogYm9vbGVhbik7XHJcbiAgICBnZXQgcGF1c2VPbkZvY3VzKCk6IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIElmIGB0cnVlYCwgJ3ByZXZpb3VzJyBhbmQgJ25leHQnIG5hdmlnYXRpb24gYXJyb3dzIHdpbGwgYmUgdmlzaWJsZSBvbiB0aGUgc2xpZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHNpbmNlIDIuMi4wXHJcbiAgICAgKi9cclxuICAgIHNob3dOYXZpZ2F0aW9uQXJyb3dzOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBgdHJ1ZWAsIG5hdmlnYXRpb24gaW5kaWNhdG9ycyBhdCB0aGUgYm90dG9tIG9mIHRoZSBzbGlkZSB3aWxsIGJlIHZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQHNpbmNlIDIuMi4wXHJcbiAgICAgKi9cclxuICAgIHNob3dOYXZpZ2F0aW9uSW5kaWNhdG9yczogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogQW4gZXZlbnQgZW1pdHRlZCBqdXN0IGJlZm9yZSB0aGUgc2xpZGUgdHJhbnNpdGlvbiBzdGFydHMuXHJcbiAgICAgKlxyXG4gICAgICogU2VlIFtgTmdiU2xpZGVFdmVudGBdKCMvY29tcG9uZW50cy9jYXJvdXNlbC9hcGkjTmdiU2xpZGVFdmVudCkgZm9yIHBheWxvYWQgZGV0YWlscy5cclxuICAgICAqL1xyXG4gICAgc2xpZGU6IEV2ZW50RW1pdHRlcjxOZ2JTbGlkZUV2ZW50PjtcclxuICAgIC8qKlxyXG4gICAgICogQW4gZXZlbnQgZW1pdHRlZCByaWdodCBhZnRlciB0aGUgc2xpZGUgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogU2VlIFtgTmdiU2xpZGVFdmVudGBdKCMvY29tcG9uZW50cy9jYXJvdXNlbC9hcGkjTmdiU2xpZGVFdmVudCkgZm9yIHBheWxvYWQgZGV0YWlscy5cclxuICAgICAqXHJcbiAgICAgKiBAc2luY2UgOC4wLjBcclxuICAgICAqL1xyXG4gICAgc2xpZDogRXZlbnRFbWl0dGVyPE5nYlNsaWRlRXZlbnQ+O1xyXG4gICAgcHJpdmF0ZSBfdHJhbnNpdGlvbklkcztcclxuICAgIHNldCBtb3VzZUhvdmVyKHZhbHVlOiBib29sZWFuKTtcclxuICAgIGdldCBtb3VzZUhvdmVyKCk6IGJvb2xlYW47XHJcbiAgICBzZXQgZm9jdXNlZCh2YWx1ZTogYm9vbGVhbik7XHJcbiAgICBnZXQgZm9jdXNlZCgpOiBib29sZWFuO1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBOZ2JDYXJvdXNlbENvbmZpZywgX3BsYXRmb3JtSWQ6IGFueSwgX25nWm9uZTogTmdab25lLCBfY2Q6IENoYW5nZURldGVjdG9yUmVmLCBfY29udGFpbmVyOiBFbGVtZW50UmVmKTtcclxuICAgIGFycm93TGVmdCgpOiB2b2lkO1xyXG4gICAgYXJyb3dSaWdodCgpOiB2b2lkO1xyXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XHJcbiAgICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKTogdm9pZDtcclxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogTmF2aWdhdGVzIHRvIGEgc2xpZGUgd2l0aCB0aGUgc3BlY2lmaWVkIGlkZW50aWZpZXIuXHJcbiAgICAgKi9cclxuICAgIHNlbGVjdChzbGlkZUlkOiBzdHJpbmcsIHNvdXJjZT86IE5nYlNsaWRlRXZlbnRTb3VyY2UpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYXZpZ2F0ZXMgdG8gdGhlIHByZXZpb3VzIHNsaWRlLlxyXG4gICAgICovXHJcbiAgICBwcmV2KHNvdXJjZT86IE5nYlNsaWRlRXZlbnRTb3VyY2UpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYXZpZ2F0ZXMgdG8gdGhlIG5leHQgc2xpZGUuXHJcbiAgICAgKi9cclxuICAgIG5leHQoc291cmNlPzogTmdiU2xpZGVFdmVudFNvdXJjZSk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIFBhdXNlcyBjeWNsaW5nIHRocm91Z2ggdGhlIHNsaWRlcy5cclxuICAgICAqL1xyXG4gICAgcGF1c2UoKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogUmVzdGFydHMgY3ljbGluZyB0aHJvdWdoIHRoZSBzbGlkZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxyXG4gICAgICovXHJcbiAgICBjeWNsZSgpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGZvY3VzIG9uIHRoZSBjYXJvdXNlbC5cclxuICAgICAqL1xyXG4gICAgZm9jdXMoKTogdm9pZDtcclxuICAgIHByaXZhdGUgX2N5Y2xlVG9TZWxlY3RlZDtcclxuICAgIHByaXZhdGUgX2dldFNsaWRlRXZlbnREaXJlY3Rpb247XHJcbiAgICBwcml2YXRlIF9nZXRTbGlkZUJ5SWQ7XHJcbiAgICBwcml2YXRlIF9nZXRTbGlkZUlkeEJ5SWQ7XHJcbiAgICBwcml2YXRlIF9nZXROZXh0U2xpZGU7XHJcbiAgICBwcml2YXRlIF9nZXRQcmV2U2xpZGU7XHJcbiAgICBwcml2YXRlIF9nZXRTbGlkZUVsZW1lbnQ7XHJcbn1cclxuLyoqXHJcbiAqIEEgc2xpZGUgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgcmlnaHQgYWZ0ZXIgdGhlIHNsaWRlIHRyYW5zaXRpb24gaXMgY29tcGxldGVkLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBOZ2JTbGlkZUV2ZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHByZXZpb3VzIHNsaWRlIGlkLlxyXG4gICAgICovXHJcbiAgICBwcmV2OiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IHNsaWRlIGlkLlxyXG4gICAgICovXHJcbiAgICBjdXJyZW50OiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzbGlkZSBldmVudCBkaXJlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogUG9zc2libGUgdmFsdWVzIGFyZSBgJ2xlZnQnIHwgJ3JpZ2h0J2AuXHJcbiAgICAgKi9cclxuICAgIGRpcmVjdGlvbjogTmdiU2xpZGVFdmVudERpcmVjdGlvbjtcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgcGF1c2UoKSBtZXRob2Qgd2FzIGNhbGxlZCAoYW5kIG5vIGN5Y2xlKCkgY2FsbCB3YXMgZG9uZSBhZnRlcndhcmRzKS5cclxuICAgICAqXHJcbiAgICAgKiBAc2luY2UgNS4xLjBcclxuICAgICAqL1xyXG4gICAgcGF1c2VkOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTb3VyY2UgdHJpZ2dlcmluZyB0aGUgc2xpZGUgY2hhbmdlIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIFBvc3NpYmxlIHZhbHVlcyBhcmUgYCd0aW1lcicgfCAnYXJyb3dMZWZ0JyB8ICdhcnJvd1JpZ2h0JyB8ICdpbmRpY2F0b3InYFxyXG4gICAgICpcclxuICAgICAqIEBzaW5jZSA1LjEuMFxyXG4gICAgICovXHJcbiAgICBzb3VyY2U/OiBOZ2JTbGlkZUV2ZW50U291cmNlO1xyXG59XHJcbi8qKlxyXG4gKiBBIHNsaWRlIGNoYW5nZSBldmVudCBlbWl0dGVkIHJpZ2h0IGFmdGVyIHRoZSBzbGlkZSB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlZC5cclxuICpcclxuICogQHNpbmNlIDguMC4wXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE5nYlNpbmdsZVNsaWRlRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiB0cnVlIGlmIHRoZSBzbGlkZSBpcyBzaG93biwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIGlzU2hvd246IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzbGlkZSBldmVudCBkaXJlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogUG9zc2libGUgdmFsdWVzIGFyZSBgJ2xlZnQnIHwgJ3JpZ2h0J2AuXHJcbiAgICAgKi9cclxuICAgIGRpcmVjdGlvbjogTmdiU2xpZGVFdmVudERpcmVjdGlvbjtcclxuICAgIC8qKlxyXG4gICAgICogU291cmNlIHRyaWdnZXJpbmcgdGhlIHNsaWRlIGNoYW5nZSBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGAndGltZXInIHwgJ2Fycm93TGVmdCcgfCAnYXJyb3dSaWdodCcgfCAnaW5kaWNhdG9yJ2BcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHNvdXJjZT86IE5nYlNsaWRlRXZlbnRTb3VyY2U7XHJcbn1cclxuZXhwb3J0IGRlY2xhcmUgZW51bSBOZ2JTbGlkZUV2ZW50U291cmNlIHtcclxuICAgIFRJTUVSID0gXCJ0aW1lclwiLFxyXG4gICAgQVJST1dfTEVGVCA9IFwiYXJyb3dMZWZ0XCIsXHJcbiAgICBBUlJPV19SSUdIVCA9IFwiYXJyb3dSaWdodFwiLFxyXG4gICAgSU5ESUNBVE9SID0gXCJpbmRpY2F0b3JcIlxyXG59XHJcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE5HQl9DQVJPVVNFTF9ESVJFQ1RJVkVTOiAodHlwZW9mIE5nYlNsaWRlIHwgdHlwZW9mIE5nYkNhcm91c2VsKVtdO1xyXG4iXX0=