import { EventEmitter, OnChanges, SimpleChanges, TemplateRef } from '@angular/core';
import { NgbPaginationConfig } from './pagination-config';
/**
 * A context for the
 * * `NgbPaginationFirst`
 * * `NgbPaginationPrevious`
 * * `NgbPaginationNext`
 * * `NgbPaginationLast`
 * * `NgbPaginationEllipsis`
 * * `NgbPaginationPages`
 *
 * link templates in case you want to override one.
 *
 * @since 4.1.0
 */
import * as ɵngcc0 from '@angular/core';
export interface NgbPaginationLinkContext {
    /**
     * Page number displayed by the current link.
     */
    currentPage: number;
    /**
     * If `true`, the current link is disabled.
     */
    disabled: boolean;
}
/**
 * A context for the `NgbPaginationNumber` link template in case you want to override one.
 *
 * Extends `NgbPaginationLinkContext`.
 *
 * @since 4.1.0
 */
export interface NgbPaginationNumberContext extends NgbPaginationLinkContext {
    /**
     * The page number, displayed by the current page link.
     */
    $implicit: number;
}
/**
 * A context for the `NgbPaginationPages` pages template in case you want to override
 * the way all pages are displayed.
 *
 * @since 9.1.0
 */
export interface NgbPaginationPagesContext {
    /**
     * The currently selected page number.
     */
    $implicit: number;
    /**
     * If `true`, pagination is disabled.
     */
    disabled: boolean;
    /**
     * Pages numbers that should be rendered starting with 1.
     */
    pages: number[];
}
/**
 * A directive to match the 'ellipsis' link template
 *
 * @since 4.1.0
 */
export declare class NgbPaginationEllipsis {
    templateRef: TemplateRef<NgbPaginationLinkContext>;
    constructor(templateRef: TemplateRef<NgbPaginationLinkContext>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbPaginationEllipsis, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgbPaginationEllipsis, "ng-template[ngbPaginationEllipsis]", never, {}, {}, never>;
}
/**
 * A directive to match the 'first' link template
 *
 * @since 4.1.0
 */
export declare class NgbPaginationFirst {
    templateRef: TemplateRef<NgbPaginationLinkContext>;
    constructor(templateRef: TemplateRef<NgbPaginationLinkContext>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbPaginationFirst, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgbPaginationFirst, "ng-template[ngbPaginationFirst]", never, {}, {}, never>;
}
/**
 * A directive to match the 'last' link template
 *
 * @since 4.1.0
 */
export declare class NgbPaginationLast {
    templateRef: TemplateRef<NgbPaginationLinkContext>;
    constructor(templateRef: TemplateRef<NgbPaginationLinkContext>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbPaginationLast, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgbPaginationLast, "ng-template[ngbPaginationLast]", never, {}, {}, never>;
}
/**
 * A directive to match the 'next' link template
 *
 * @since 4.1.0
 */
export declare class NgbPaginationNext {
    templateRef: TemplateRef<NgbPaginationLinkContext>;
    constructor(templateRef: TemplateRef<NgbPaginationLinkContext>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbPaginationNext, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgbPaginationNext, "ng-template[ngbPaginationNext]", never, {}, {}, never>;
}
/**
 * A directive to match the page 'number' link template
 *
 * @since 4.1.0
 */
export declare class NgbPaginationNumber {
    templateRef: TemplateRef<NgbPaginationNumberContext>;
    constructor(templateRef: TemplateRef<NgbPaginationNumberContext>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbPaginationNumber, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgbPaginationNumber, "ng-template[ngbPaginationNumber]", never, {}, {}, never>;
}
/**
 * A directive to match the 'previous' link template
 *
 * @since 4.1.0
 */
export declare class NgbPaginationPrevious {
    templateRef: TemplateRef<NgbPaginationLinkContext>;
    constructor(templateRef: TemplateRef<NgbPaginationLinkContext>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbPaginationPrevious, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgbPaginationPrevious, "ng-template[ngbPaginationPrevious]", never, {}, {}, never>;
}
/**
 * A directive to match the 'pages' whole content
 *
 * @since 9.1.0
 */
export declare class NgbPaginationPages {
    templateRef: TemplateRef<NgbPaginationPagesContext>;
    constructor(templateRef: TemplateRef<NgbPaginationPagesContext>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbPaginationPages, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgbPaginationPages, "ng-template[ngbPaginationPages]", never, {}, {}, never>;
}
/**
 * A component that displays page numbers and allows to customize them in several ways.
 */
export declare class NgbPagination implements OnChanges {
    pageCount: number;
    pages: number[];
    tplEllipsis: NgbPaginationEllipsis;
    tplFirst: NgbPaginationFirst;
    tplLast: NgbPaginationLast;
    tplNext: NgbPaginationNext;
    tplNumber: NgbPaginationNumber;
    tplPrevious: NgbPaginationPrevious;
    tplPages: NgbPaginationPages;
    /**
     * If `true`, pagination links will be disabled.
     */
    disabled: boolean;
    /**
     * If `true`, the "First" and "Last" page links are shown.
     */
    boundaryLinks: boolean;
    /**
     * If `true`, the "Next" and "Previous" page links are shown.
     */
    directionLinks: boolean;
    /**
     * If `true`, the ellipsis symbols and first/last page numbers will be shown when `maxSize` > number of pages.
     */
    ellipses: boolean;
    /**
     * Whether to rotate pages when `maxSize` > number of pages.
     *
     * The current page always stays in the middle if `true`.
     */
    rotate: boolean;
    /**
     *  The number of items in your paginated collection.
     *
     *  Note, that this is not the number of pages. Page numbers are calculated dynamically based on
     *  `collectionSize` and `pageSize`. Ex. if you have 100 items in your collection and displaying 20 items per page,
     *  you'll end up with 5 pages.
     */
    collectionSize: number;
    /**
     *  The maximum number of pages to display.
     */
    maxSize: number;
    /**
     *  The current page.
     *
     *  Page numbers start with `1`.
     */
    page: number;
    /**
     *  The number of items per page.
     */
    pageSize: number;
    /**
     *  An event fired when the page is changed. Will fire only if collection size is set and all values are valid.
     *
     *  Event payload is the number of the newly selected page.
     *
     *  Page numbers start with `1`.
     */
    pageChange: EventEmitter<number>;
    /**
     * The pagination display size.
     *
     * Bootstrap currently supports small and large sizes.
     */
    size: 'sm' | 'lg';
    constructor(config: NgbPaginationConfig);
    hasPrevious(): boolean;
    hasNext(): boolean;
    nextDisabled(): boolean;
    previousDisabled(): boolean;
    selectPage(pageNumber: number): void;
    ngOnChanges(changes: SimpleChanges): void;
    isEllipsis(pageNumber: any): boolean;
    /**
     * Appends ellipses and first/last page number to the displayed pages
     */
    private _applyEllipses;
    /**
     * Rotates page numbers based on maxSize items visible.
     * Currently selected page stays in the middle:
     *
     * Ex. for selected page = 6:
     * [5,*6*,7] for maxSize = 3
     * [4,5,*6*,7] for maxSize = 4
     */
    private _applyRotation;
    /**
     * Paginates page numbers based on maxSize items per page.
     */
    private _applyPagination;
    private _setPageInRange;
    private _updatePages;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbPagination, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NgbPagination, "ngb-pagination", never, { "page": "page"; "disabled": "disabled"; "boundaryLinks": "boundaryLinks"; "directionLinks": "directionLinks"; "ellipses": "ellipses"; "maxSize": "maxSize"; "pageSize": "pageSize"; "rotate": "rotate"; "size": "size"; "collectionSize": "collectionSize"; }, { "pageChange": "pageChange"; }, ["tplEllipsis", "tplFirst", "tplLast", "tplNext", "tplNumber", "tplPrevious", "tplPages"], never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnaW5hdGlvbi5kLnRzIiwic291cmNlcyI6WyJwYWdpbmF0aW9uLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBOZ2JQYWdpbmF0aW9uQ29uZmlnIH0gZnJvbSAnLi9wYWdpbmF0aW9uLWNvbmZpZyc7XHJcbi8qKlxyXG4gKiBBIGNvbnRleHQgZm9yIHRoZVxyXG4gKiAqIGBOZ2JQYWdpbmF0aW9uRmlyc3RgXHJcbiAqICogYE5nYlBhZ2luYXRpb25QcmV2aW91c2BcclxuICogKiBgTmdiUGFnaW5hdGlvbk5leHRgXHJcbiAqICogYE5nYlBhZ2luYXRpb25MYXN0YFxyXG4gKiAqIGBOZ2JQYWdpbmF0aW9uRWxsaXBzaXNgXHJcbiAqICogYE5nYlBhZ2luYXRpb25QYWdlc2BcclxuICpcclxuICogbGluayB0ZW1wbGF0ZXMgaW4gY2FzZSB5b3Ugd2FudCB0byBvdmVycmlkZSBvbmUuXHJcbiAqXHJcbiAqIEBzaW5jZSA0LjEuMFxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBOZ2JQYWdpbmF0aW9uTGlua0NvbnRleHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBQYWdlIG51bWJlciBkaXNwbGF5ZWQgYnkgdGhlIGN1cnJlbnQgbGluay5cclxuICAgICAqL1xyXG4gICAgY3VycmVudFBhZ2U6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogSWYgYHRydWVgLCB0aGUgY3VycmVudCBsaW5rIGlzIGRpc2FibGVkLlxyXG4gICAgICovXHJcbiAgICBkaXNhYmxlZDogYm9vbGVhbjtcclxufVxyXG4vKipcclxuICogQSBjb250ZXh0IGZvciB0aGUgYE5nYlBhZ2luYXRpb25OdW1iZXJgIGxpbmsgdGVtcGxhdGUgaW4gY2FzZSB5b3Ugd2FudCB0byBvdmVycmlkZSBvbmUuXHJcbiAqXHJcbiAqIEV4dGVuZHMgYE5nYlBhZ2luYXRpb25MaW5rQ29udGV4dGAuXHJcbiAqXHJcbiAqIEBzaW5jZSA0LjEuMFxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBOZ2JQYWdpbmF0aW9uTnVtYmVyQ29udGV4dCBleHRlbmRzIE5nYlBhZ2luYXRpb25MaW5rQ29udGV4dCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwYWdlIG51bWJlciwgZGlzcGxheWVkIGJ5IHRoZSBjdXJyZW50IHBhZ2UgbGluay5cclxuICAgICAqL1xyXG4gICAgJGltcGxpY2l0OiBudW1iZXI7XHJcbn1cclxuLyoqXHJcbiAqIEEgY29udGV4dCBmb3IgdGhlIGBOZ2JQYWdpbmF0aW9uUGFnZXNgIHBhZ2VzIHRlbXBsYXRlIGluIGNhc2UgeW91IHdhbnQgdG8gb3ZlcnJpZGVcclxuICogdGhlIHdheSBhbGwgcGFnZXMgYXJlIGRpc3BsYXllZC5cclxuICpcclxuICogQHNpbmNlIDkuMS4wXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE5nYlBhZ2luYXRpb25QYWdlc0NvbnRleHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIHBhZ2UgbnVtYmVyLlxyXG4gICAgICovXHJcbiAgICAkaW1wbGljaXQ6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogSWYgYHRydWVgLCBwYWdpbmF0aW9uIGlzIGRpc2FibGVkLlxyXG4gICAgICovXHJcbiAgICBkaXNhYmxlZDogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogUGFnZXMgbnVtYmVycyB0aGF0IHNob3VsZCBiZSByZW5kZXJlZCBzdGFydGluZyB3aXRoIDEuXHJcbiAgICAgKi9cclxuICAgIHBhZ2VzOiBudW1iZXJbXTtcclxufVxyXG4vKipcclxuICogQSBkaXJlY3RpdmUgdG8gbWF0Y2ggdGhlICdlbGxpcHNpcycgbGluayB0ZW1wbGF0ZVxyXG4gKlxyXG4gKiBAc2luY2UgNC4xLjBcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5nYlBhZ2luYXRpb25FbGxpcHNpcyB7XHJcbiAgICB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8TmdiUGFnaW5hdGlvbkxpbmtDb250ZXh0PjtcclxuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxOZ2JQYWdpbmF0aW9uTGlua0NvbnRleHQ+KTtcclxufVxyXG4vKipcclxuICogQSBkaXJlY3RpdmUgdG8gbWF0Y2ggdGhlICdmaXJzdCcgbGluayB0ZW1wbGF0ZVxyXG4gKlxyXG4gKiBAc2luY2UgNC4xLjBcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5nYlBhZ2luYXRpb25GaXJzdCB7XHJcbiAgICB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8TmdiUGFnaW5hdGlvbkxpbmtDb250ZXh0PjtcclxuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxOZ2JQYWdpbmF0aW9uTGlua0NvbnRleHQ+KTtcclxufVxyXG4vKipcclxuICogQSBkaXJlY3RpdmUgdG8gbWF0Y2ggdGhlICdsYXN0JyBsaW5rIHRlbXBsYXRlXHJcbiAqXHJcbiAqIEBzaW5jZSA0LjEuMFxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmdiUGFnaW5hdGlvbkxhc3Qge1xyXG4gICAgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPE5nYlBhZ2luYXRpb25MaW5rQ29udGV4dD47XHJcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8TmdiUGFnaW5hdGlvbkxpbmtDb250ZXh0Pik7XHJcbn1cclxuLyoqXHJcbiAqIEEgZGlyZWN0aXZlIHRvIG1hdGNoIHRoZSAnbmV4dCcgbGluayB0ZW1wbGF0ZVxyXG4gKlxyXG4gKiBAc2luY2UgNC4xLjBcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5nYlBhZ2luYXRpb25OZXh0IHtcclxuICAgIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxOZ2JQYWdpbmF0aW9uTGlua0NvbnRleHQ+O1xyXG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPE5nYlBhZ2luYXRpb25MaW5rQ29udGV4dD4pO1xyXG59XHJcbi8qKlxyXG4gKiBBIGRpcmVjdGl2ZSB0byBtYXRjaCB0aGUgcGFnZSAnbnVtYmVyJyBsaW5rIHRlbXBsYXRlXHJcbiAqXHJcbiAqIEBzaW5jZSA0LjEuMFxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmdiUGFnaW5hdGlvbk51bWJlciB7XHJcbiAgICB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8TmdiUGFnaW5hdGlvbk51bWJlckNvbnRleHQ+O1xyXG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPE5nYlBhZ2luYXRpb25OdW1iZXJDb250ZXh0Pik7XHJcbn1cclxuLyoqXHJcbiAqIEEgZGlyZWN0aXZlIHRvIG1hdGNoIHRoZSAncHJldmlvdXMnIGxpbmsgdGVtcGxhdGVcclxuICpcclxuICogQHNpbmNlIDQuMS4wXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOZ2JQYWdpbmF0aW9uUHJldmlvdXMge1xyXG4gICAgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPE5nYlBhZ2luYXRpb25MaW5rQ29udGV4dD47XHJcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8TmdiUGFnaW5hdGlvbkxpbmtDb250ZXh0Pik7XHJcbn1cclxuLyoqXHJcbiAqIEEgZGlyZWN0aXZlIHRvIG1hdGNoIHRoZSAncGFnZXMnIHdob2xlIGNvbnRlbnRcclxuICpcclxuICogQHNpbmNlIDkuMS4wXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOZ2JQYWdpbmF0aW9uUGFnZXMge1xyXG4gICAgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPE5nYlBhZ2luYXRpb25QYWdlc0NvbnRleHQ+O1xyXG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPE5nYlBhZ2luYXRpb25QYWdlc0NvbnRleHQ+KTtcclxufVxyXG4vKipcclxuICogQSBjb21wb25lbnQgdGhhdCBkaXNwbGF5cyBwYWdlIG51bWJlcnMgYW5kIGFsbG93cyB0byBjdXN0b21pemUgdGhlbSBpbiBzZXZlcmFsIHdheXMuXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOZ2JQYWdpbmF0aW9uIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcclxuICAgIHBhZ2VDb3VudDogbnVtYmVyO1xyXG4gICAgcGFnZXM6IG51bWJlcltdO1xyXG4gICAgdHBsRWxsaXBzaXM6IE5nYlBhZ2luYXRpb25FbGxpcHNpcztcclxuICAgIHRwbEZpcnN0OiBOZ2JQYWdpbmF0aW9uRmlyc3Q7XHJcbiAgICB0cGxMYXN0OiBOZ2JQYWdpbmF0aW9uTGFzdDtcclxuICAgIHRwbE5leHQ6IE5nYlBhZ2luYXRpb25OZXh0O1xyXG4gICAgdHBsTnVtYmVyOiBOZ2JQYWdpbmF0aW9uTnVtYmVyO1xyXG4gICAgdHBsUHJldmlvdXM6IE5nYlBhZ2luYXRpb25QcmV2aW91cztcclxuICAgIHRwbFBhZ2VzOiBOZ2JQYWdpbmF0aW9uUGFnZXM7XHJcbiAgICAvKipcclxuICAgICAqIElmIGB0cnVlYCwgcGFnaW5hdGlvbiBsaW5rcyB3aWxsIGJlIGRpc2FibGVkLlxyXG4gICAgICovXHJcbiAgICBkaXNhYmxlZDogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogSWYgYHRydWVgLCB0aGUgXCJGaXJzdFwiIGFuZCBcIkxhc3RcIiBwYWdlIGxpbmtzIGFyZSBzaG93bi5cclxuICAgICAqL1xyXG4gICAgYm91bmRhcnlMaW5rczogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogSWYgYHRydWVgLCB0aGUgXCJOZXh0XCIgYW5kIFwiUHJldmlvdXNcIiBwYWdlIGxpbmtzIGFyZSBzaG93bi5cclxuICAgICAqL1xyXG4gICAgZGlyZWN0aW9uTGlua3M6IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIElmIGB0cnVlYCwgdGhlIGVsbGlwc2lzIHN5bWJvbHMgYW5kIGZpcnN0L2xhc3QgcGFnZSBudW1iZXJzIHdpbGwgYmUgc2hvd24gd2hlbiBgbWF4U2l6ZWAgPiBudW1iZXIgb2YgcGFnZXMuXHJcbiAgICAgKi9cclxuICAgIGVsbGlwc2VzOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIHJvdGF0ZSBwYWdlcyB3aGVuIGBtYXhTaXplYCA+IG51bWJlciBvZiBwYWdlcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgY3VycmVudCBwYWdlIGFsd2F5cyBzdGF5cyBpbiB0aGUgbWlkZGxlIGlmIGB0cnVlYC5cclxuICAgICAqL1xyXG4gICAgcm90YXRlOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG51bWJlciBvZiBpdGVtcyBpbiB5b3VyIHBhZ2luYXRlZCBjb2xsZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqICBOb3RlLCB0aGF0IHRoaXMgaXMgbm90IHRoZSBudW1iZXIgb2YgcGFnZXMuIFBhZ2UgbnVtYmVycyBhcmUgY2FsY3VsYXRlZCBkeW5hbWljYWxseSBiYXNlZCBvblxyXG4gICAgICogIGBjb2xsZWN0aW9uU2l6ZWAgYW5kIGBwYWdlU2l6ZWAuIEV4LiBpZiB5b3UgaGF2ZSAxMDAgaXRlbXMgaW4geW91ciBjb2xsZWN0aW9uIGFuZCBkaXNwbGF5aW5nIDIwIGl0ZW1zIHBlciBwYWdlLFxyXG4gICAgICogIHlvdSdsbCBlbmQgdXAgd2l0aCA1IHBhZ2VzLlxyXG4gICAgICovXHJcbiAgICBjb2xsZWN0aW9uU2l6ZTogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG1heGltdW0gbnVtYmVyIG9mIHBhZ2VzIHRvIGRpc3BsYXkuXHJcbiAgICAgKi9cclxuICAgIG1heFNpemU6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBjdXJyZW50IHBhZ2UuXHJcbiAgICAgKlxyXG4gICAgICogIFBhZ2UgbnVtYmVycyBzdGFydCB3aXRoIGAxYC5cclxuICAgICAqL1xyXG4gICAgcGFnZTogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG51bWJlciBvZiBpdGVtcyBwZXIgcGFnZS5cclxuICAgICAqL1xyXG4gICAgcGFnZVNpemU6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogIEFuIGV2ZW50IGZpcmVkIHdoZW4gdGhlIHBhZ2UgaXMgY2hhbmdlZC4gV2lsbCBmaXJlIG9ubHkgaWYgY29sbGVjdGlvbiBzaXplIGlzIHNldCBhbmQgYWxsIHZhbHVlcyBhcmUgdmFsaWQuXHJcbiAgICAgKlxyXG4gICAgICogIEV2ZW50IHBheWxvYWQgaXMgdGhlIG51bWJlciBvZiB0aGUgbmV3bHkgc2VsZWN0ZWQgcGFnZS5cclxuICAgICAqXHJcbiAgICAgKiAgUGFnZSBudW1iZXJzIHN0YXJ0IHdpdGggYDFgLlxyXG4gICAgICovXHJcbiAgICBwYWdlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8bnVtYmVyPjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBhZ2luYXRpb24gZGlzcGxheSBzaXplLlxyXG4gICAgICpcclxuICAgICAqIEJvb3RzdHJhcCBjdXJyZW50bHkgc3VwcG9ydHMgc21hbGwgYW5kIGxhcmdlIHNpemVzLlxyXG4gICAgICovXHJcbiAgICBzaXplOiAnc20nIHwgJ2xnJztcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZzogTmdiUGFnaW5hdGlvbkNvbmZpZyk7XHJcbiAgICBoYXNQcmV2aW91cygpOiBib29sZWFuO1xyXG4gICAgaGFzTmV4dCgpOiBib29sZWFuO1xyXG4gICAgbmV4dERpc2FibGVkKCk6IGJvb2xlYW47XHJcbiAgICBwcmV2aW91c0Rpc2FibGVkKCk6IGJvb2xlYW47XHJcbiAgICBzZWxlY3RQYWdlKHBhZ2VOdW1iZXI6IG51bWJlcik6IHZvaWQ7XHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZDtcclxuICAgIGlzRWxsaXBzaXMocGFnZU51bWJlcjogYW55KTogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBlbGxpcHNlcyBhbmQgZmlyc3QvbGFzdCBwYWdlIG51bWJlciB0byB0aGUgZGlzcGxheWVkIHBhZ2VzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX2FwcGx5RWxsaXBzZXM7XHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZXMgcGFnZSBudW1iZXJzIGJhc2VkIG9uIG1heFNpemUgaXRlbXMgdmlzaWJsZS5cclxuICAgICAqIEN1cnJlbnRseSBzZWxlY3RlZCBwYWdlIHN0YXlzIGluIHRoZSBtaWRkbGU6XHJcbiAgICAgKlxyXG4gICAgICogRXguIGZvciBzZWxlY3RlZCBwYWdlID0gNjpcclxuICAgICAqIFs1LCo2Kiw3XSBmb3IgbWF4U2l6ZSA9IDNcclxuICAgICAqIFs0LDUsKjYqLDddIGZvciBtYXhTaXplID0gNFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9hcHBseVJvdGF0aW9uO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQYWdpbmF0ZXMgcGFnZSBudW1iZXJzIGJhc2VkIG9uIG1heFNpemUgaXRlbXMgcGVyIHBhZ2UuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX2FwcGx5UGFnaW5hdGlvbjtcclxuICAgIHByaXZhdGUgX3NldFBhZ2VJblJhbmdlO1xyXG4gICAgcHJpdmF0ZSBfdXBkYXRlUGFnZXM7XHJcbn1cclxuIl19