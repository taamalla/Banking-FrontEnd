import { AfterContentInit, EventEmitter, OnChanges, SimpleChanges, TemplateRef, ElementRef, NgZone } from '@angular/core';
import { Observable } from 'rxjs';
import { NgbToastConfig } from './toast-config';
/**
 * This directive allows the usage of HTML markup or other directives
 * inside of the toast's header.
 *
 * @since 5.0.0
 */
import * as ɵngcc0 from '@angular/core';
export declare class NgbToastHeader {
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbToastHeader, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgbToastHeader, "[ngbToastHeader]", never, {}, {}, never>;
}
/**
 * Toasts provide feedback messages as notifications to the user.
 * Goal is to mimic the push notifications available both on mobile and desktop operating systems.
 *
 * @since 5.0.0
 */
export declare class NgbToast implements AfterContentInit, OnChanges {
    ariaLive: string;
    private _zone;
    private _element;
    /**
     * If `true`, toast opening and closing will be animated.
     *
     * Animation is triggered only when the `.hide()` or `.show()` functions are called
     *
     * @since 8.0.0
     */
    animation: boolean;
    private _timeoutID;
    /**
     * Delay after which the toast will hide (ms).
     * default: `500` (ms) (inherited from NgbToastConfig)
     */
    delay: number;
    /**
     * Auto hide the toast after a delay in ms.
     * default: `true` (inherited from NgbToastConfig)
     */
    autohide: boolean;
    /**
     * Text to be used as toast's header.
     * Ignored if a ContentChild template is specified at the same time.
     */
    header: string;
    /**
     * A template like `<ng-template ngbToastHeader></ng-template>` can be
     * used in the projected content to allow markup usage.
     */
    contentHeaderTpl: TemplateRef<any> | null;
    /**
     * An event fired after the animation triggered by calling `.show()` method has finished.
     *
     * @since 8.0.0
     */
    shown: EventEmitter<void>;
    /**
     * An event fired after the animation triggered by calling `.hide()` method has finished.
     *
     * It can only occur in 2 different scenarios:
     * - `autohide` timeout fires
     * - user clicks on a closing cross
     *
     * Additionally this output is purely informative. The toast won't be removed from DOM automatically, it's up
     * to the user to take care of that.
     *
     * @since 8.0.0
     */
    hidden: EventEmitter<void>;
    constructor(ariaLive: string, config: NgbToastConfig, _zone: NgZone, _element: ElementRef);
    ngAfterContentInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    /**
     * Triggers toast closing programmatically.
     *
     * The returned observable will emit and be completed once the closing transition has finished.
     * If the animations are turned off this happens synchronously.
     *
     * Alternatively you could listen or subscribe to the `(hidden)` output
     *
     * @since 8.0.0
     */
    hide(): Observable<void>;
    /**
     * Triggers toast opening programmatically.
     *
     * The returned observable will emit and be completed once the opening transition has finished.
     * If the animations are turned off this happens synchronously.
     *
     * Alternatively you could listen or subscribe to the `(shown)` output
     *
     * @since 8.0.0
     */
    show(): Observable<void>;
    private _init;
    private _clearTimeout;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbToast, [{ attribute: "aria-live"; }, null, null, null]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NgbToast, "ngb-toast", ["ngbToast"], { "delay": "delay"; "autohide": "autohide"; "animation": "animation"; "header": "header"; }, { "shown": "shown"; "hidden": "hidden"; }, ["contentHeaderTpl"], ["*"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9hc3QuZC50cyIsInNvdXJjZXMiOlsidG9hc3QuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgRXZlbnRFbWl0dGVyLCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMsIFRlbXBsYXRlUmVmLCBFbGVtZW50UmVmLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBOZ2JUb2FzdENvbmZpZyB9IGZyb20gJy4vdG9hc3QtY29uZmlnJztcclxuLyoqXHJcbiAqIFRoaXMgZGlyZWN0aXZlIGFsbG93cyB0aGUgdXNhZ2Ugb2YgSFRNTCBtYXJrdXAgb3Igb3RoZXIgZGlyZWN0aXZlc1xyXG4gKiBpbnNpZGUgb2YgdGhlIHRvYXN0J3MgaGVhZGVyLlxyXG4gKlxyXG4gKiBAc2luY2UgNS4wLjBcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5nYlRvYXN0SGVhZGVyIHtcclxufVxyXG4vKipcclxuICogVG9hc3RzIHByb3ZpZGUgZmVlZGJhY2sgbWVzc2FnZXMgYXMgbm90aWZpY2F0aW9ucyB0byB0aGUgdXNlci5cclxuICogR29hbCBpcyB0byBtaW1pYyB0aGUgcHVzaCBub3RpZmljYXRpb25zIGF2YWlsYWJsZSBib3RoIG9uIG1vYmlsZSBhbmQgZGVza3RvcCBvcGVyYXRpbmcgc3lzdGVtcy5cclxuICpcclxuICogQHNpbmNlIDUuMC4wXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOZ2JUb2FzdCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uQ2hhbmdlcyB7XHJcbiAgICBhcmlhTGl2ZTogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfem9uZTtcclxuICAgIHByaXZhdGUgX2VsZW1lbnQ7XHJcbiAgICAvKipcclxuICAgICAqIElmIGB0cnVlYCwgdG9hc3Qgb3BlbmluZyBhbmQgY2xvc2luZyB3aWxsIGJlIGFuaW1hdGVkLlxyXG4gICAgICpcclxuICAgICAqIEFuaW1hdGlvbiBpcyB0cmlnZ2VyZWQgb25seSB3aGVuIHRoZSBgLmhpZGUoKWAgb3IgYC5zaG93KClgIGZ1bmN0aW9ucyBhcmUgY2FsbGVkXHJcbiAgICAgKlxyXG4gICAgICogQHNpbmNlIDguMC4wXHJcbiAgICAgKi9cclxuICAgIGFuaW1hdGlvbjogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgX3RpbWVvdXRJRDtcclxuICAgIC8qKlxyXG4gICAgICogRGVsYXkgYWZ0ZXIgd2hpY2ggdGhlIHRvYXN0IHdpbGwgaGlkZSAobXMpLlxyXG4gICAgICogZGVmYXVsdDogYDUwMGAgKG1zKSAoaW5oZXJpdGVkIGZyb20gTmdiVG9hc3RDb25maWcpXHJcbiAgICAgKi9cclxuICAgIGRlbGF5OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIEF1dG8gaGlkZSB0aGUgdG9hc3QgYWZ0ZXIgYSBkZWxheSBpbiBtcy5cclxuICAgICAqIGRlZmF1bHQ6IGB0cnVlYCAoaW5oZXJpdGVkIGZyb20gTmdiVG9hc3RDb25maWcpXHJcbiAgICAgKi9cclxuICAgIGF1dG9oaWRlOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUZXh0IHRvIGJlIHVzZWQgYXMgdG9hc3QncyBoZWFkZXIuXHJcbiAgICAgKiBJZ25vcmVkIGlmIGEgQ29udGVudENoaWxkIHRlbXBsYXRlIGlzIHNwZWNpZmllZCBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gICAgICovXHJcbiAgICBoZWFkZXI6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogQSB0ZW1wbGF0ZSBsaWtlIGA8bmctdGVtcGxhdGUgbmdiVG9hc3RIZWFkZXI+PC9uZy10ZW1wbGF0ZT5gIGNhbiBiZVxyXG4gICAgICogdXNlZCBpbiB0aGUgcHJvamVjdGVkIGNvbnRlbnQgdG8gYWxsb3cgbWFya3VwIHVzYWdlLlxyXG4gICAgICovXHJcbiAgICBjb250ZW50SGVhZGVyVHBsOiBUZW1wbGF0ZVJlZjxhbnk+IHwgbnVsbDtcclxuICAgIC8qKlxyXG4gICAgICogQW4gZXZlbnQgZmlyZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiB0cmlnZ2VyZWQgYnkgY2FsbGluZyBgLnNob3coKWAgbWV0aG9kIGhhcyBmaW5pc2hlZC5cclxuICAgICAqXHJcbiAgICAgKiBAc2luY2UgOC4wLjBcclxuICAgICAqL1xyXG4gICAgc2hvd246IEV2ZW50RW1pdHRlcjx2b2lkPjtcclxuICAgIC8qKlxyXG4gICAgICogQW4gZXZlbnQgZmlyZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiB0cmlnZ2VyZWQgYnkgY2FsbGluZyBgLmhpZGUoKWAgbWV0aG9kIGhhcyBmaW5pc2hlZC5cclxuICAgICAqXHJcbiAgICAgKiBJdCBjYW4gb25seSBvY2N1ciBpbiAyIGRpZmZlcmVudCBzY2VuYXJpb3M6XHJcbiAgICAgKiAtIGBhdXRvaGlkZWAgdGltZW91dCBmaXJlc1xyXG4gICAgICogLSB1c2VyIGNsaWNrcyBvbiBhIGNsb3NpbmcgY3Jvc3NcclxuICAgICAqXHJcbiAgICAgKiBBZGRpdGlvbmFsbHkgdGhpcyBvdXRwdXQgaXMgcHVyZWx5IGluZm9ybWF0aXZlLiBUaGUgdG9hc3Qgd29uJ3QgYmUgcmVtb3ZlZCBmcm9tIERPTSBhdXRvbWF0aWNhbGx5LCBpdCdzIHVwXHJcbiAgICAgKiB0byB0aGUgdXNlciB0byB0YWtlIGNhcmUgb2YgdGhhdC5cclxuICAgICAqXHJcbiAgICAgKiBAc2luY2UgOC4wLjBcclxuICAgICAqL1xyXG4gICAgaGlkZGVuOiBFdmVudEVtaXR0ZXI8dm9pZD47XHJcbiAgICBjb25zdHJ1Y3RvcihhcmlhTGl2ZTogc3RyaW5nLCBjb25maWc6IE5nYlRvYXN0Q29uZmlnLCBfem9uZTogTmdab25lLCBfZWxlbWVudDogRWxlbWVudFJlZik7XHJcbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZDtcclxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VycyB0b2FzdCBjbG9zaW5nIHByb2dyYW1tYXRpY2FsbHkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHJldHVybmVkIG9ic2VydmFibGUgd2lsbCBlbWl0IGFuZCBiZSBjb21wbGV0ZWQgb25jZSB0aGUgY2xvc2luZyB0cmFuc2l0aW9uIGhhcyBmaW5pc2hlZC5cclxuICAgICAqIElmIHRoZSBhbmltYXRpb25zIGFyZSB0dXJuZWQgb2ZmIHRoaXMgaGFwcGVucyBzeW5jaHJvbm91c2x5LlxyXG4gICAgICpcclxuICAgICAqIEFsdGVybmF0aXZlbHkgeW91IGNvdWxkIGxpc3RlbiBvciBzdWJzY3JpYmUgdG8gdGhlIGAoaGlkZGVuKWAgb3V0cHV0XHJcbiAgICAgKlxyXG4gICAgICogQHNpbmNlIDguMC4wXHJcbiAgICAgKi9cclxuICAgIGhpZGUoKTogT2JzZXJ2YWJsZTx2b2lkPjtcclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlcnMgdG9hc3Qgb3BlbmluZyBwcm9ncmFtbWF0aWNhbGx5LlxyXG4gICAgICpcclxuICAgICAqIFRoZSByZXR1cm5lZCBvYnNlcnZhYmxlIHdpbGwgZW1pdCBhbmQgYmUgY29tcGxldGVkIG9uY2UgdGhlIG9wZW5pbmcgdHJhbnNpdGlvbiBoYXMgZmluaXNoZWQuXHJcbiAgICAgKiBJZiB0aGUgYW5pbWF0aW9ucyBhcmUgdHVybmVkIG9mZiB0aGlzIGhhcHBlbnMgc3luY2hyb25vdXNseS5cclxuICAgICAqXHJcbiAgICAgKiBBbHRlcm5hdGl2ZWx5IHlvdSBjb3VsZCBsaXN0ZW4gb3Igc3Vic2NyaWJlIHRvIHRoZSBgKHNob3duKWAgb3V0cHV0XHJcbiAgICAgKlxyXG4gICAgICogQHNpbmNlIDguMC4wXHJcbiAgICAgKi9cclxuICAgIHNob3coKTogT2JzZXJ2YWJsZTx2b2lkPjtcclxuICAgIHByaXZhdGUgX2luaXQ7XHJcbiAgICBwcml2YXRlIF9jbGVhclRpbWVvdXQ7XHJcbn1cclxuIl19